/**
 * Sync icons from Figma, optimize them with SVGO, emit a single SVG sprite,
 * and generate an `icons` const array in `src/types.ts`.
 *
 * Requirements:
 *  - Node 18+ (global fetch)
 *
 * Env vars:
 *  FIGMA_TOKEN        (required) Personal access token
 *  FIGMA_FILE_KEY     (optional; default from code)
 *  FIGMA_NODE_ID      (optional; default from code)
 *  DRY_RUN=1          (optional) Log actions without writing files
 */

import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import { setTimeout as delay } from 'node:timers/promises';

import { optimize } from 'svgo';

// Load .env file if it exists
try {
	const dotenvPath = path.resolve(process.cwd(), '.env');
	if (fs.existsSync(dotenvPath)) {
		require('dotenv').config();
	}
} catch {
	/* ignore */
}

// Figma API constants
const FIGMA_ACCESS_TOKEN = process.env.FIGMA_ACCESS_TOKEN;
const FIGMA_FILE_KEY = process.env.FIGMA_FILE_KEY;
const FIGMA_NODE_ID = process.env.FIGMA_NODE_ID || '1:1483';
const DRY_RUN = process.env.DRY_RUN === '1';

if (!FIGMA_ACCESS_TOKEN || !FIGMA_FILE_KEY) {
	console.error('Missing FIGMA_ACCESS_TOKEN.');
	process.exit(1);
}

const ROOT = path.resolve(process.cwd());
const SPRITE_PATH = path.join(ROOT, 'src/img/sprite.svg');
const TYPES_PATH = path.join(ROOT, 'src/types.ts');

const AUTO_GENERATED_BANNER =
	'This file is auto-generated by scripts/figma-icons.ts. Do not edit manually.';

// Controls for batching and concurrency
const IMAGES_BATCH_SIZE = 90; // Figma limit-friendly
const DOWNLOAD_CONCURRENCY = 10; // parallel SVG downloads
const MAX_RETRIES = 3;
const FETCH_TIMEOUT_MS = 20_000;

// Types
interface FigmaNode {
	id: string;
	name: string;
	type: string;
	children?: FigmaNode[];
}
interface FigmaFileNodesResponse {
	nodes: Record<string, { document: FigmaNode }>;
}
interface ComponentRecord {
	id: string;
	name: string;
}
type SvgSymbol = { name: string; svg: string };

// Helper: logging format
function log(step: string, msg: string, ...rest: unknown[]) {
	console.log(`[icons:${step}] ${msg}`, ...rest);
}

// Helper: fetch with timeout
async function fetchWithTimeout<T>(p: Promise<T>, ms: number): Promise<T> {
	const t = new Promise<never>((_, rej) =>
		setTimeout(() => rej(new Error(`Request timed out after ${ms}ms`)), ms),
	);
	return Promise.race([p, t]);
}

async function http<T>(url: string, init?: RequestInit): Promise<T> {
	const doOnce = async () => {
		const res = await fetchWithTimeout(fetch(url, init), FETCH_TIMEOUT_MS);
		if (!res.ok) {
			const text = await res.text().catch(() => '');
			throw new Error(`${res.status} ${res.statusText}: ${text}`.trim());
		}
		return res.json() as Promise<T>;
	};

	let attempt = 0;
	// simple backoff for 429/5xx
	while (true) {
		try {
			return await doOnce();
		} catch (err) {
			attempt++;
			const msg = String((err as Error)?.message || err);
			const retriable = /^(4(?:29)|5)/.test(msg) || /timed out/i.test(msg);
			if (!retriable || attempt >= MAX_RETRIES) throw err;
			const backoff = Math.min(1000 * 2 ** (attempt - 1), 5000);
			log('retry', `Retrying ${url} in ${backoff}ms (attempt ${attempt}/${MAX_RETRIES})`);
			await delay(backoff);
		}
	}
}

async function figmaGet<T>(url: string): Promise<T> {
	return http<T>(url, { headers: { 'X-Figma-Token': FIGMA_ACCESS_TOKEN as string } });
}

async function downloadText(url: string): Promise<string> {
	const doOnce = async () => {
		const res = await fetchWithTimeout(fetch(url), FETCH_TIMEOUT_MS);
		if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
		return res.text();
	};
	let attempt = 0;
	while (true) {
		try {
			return await doOnce();
		} catch (err) {
			attempt++;
			const retriable = attempt < MAX_RETRIES;
			if (!retriable) throw err;
			await delay(Math.min(1000 * 2 ** (attempt - 1), 4000));
		}
	}
}

// Get icon page node
async function fetchIconRoot(): Promise<FigmaNode> {
	log('figma', `Fetching node subtree ${FIGMA_NODE_ID}`);
	const url = `https://api.figma.com/v1/files/${FIGMA_FILE_KEY}/nodes?ids=${encodeURIComponent(FIGMA_NODE_ID)}`;
	const data = await figmaGet<FigmaFileNodesResponse>(url);
	const wrapper = data.nodes[FIGMA_NODE_ID];
	if (!wrapper) throw new Error(`Icon node ${FIGMA_NODE_ID} not found in file ${FIGMA_FILE_KEY}`);
	return wrapper.document;
}

// Traverse Figma node tree
function traverseFigmaNodes(
	node: FigmaNode,
	fn: (n: FigmaNode, parents: FigmaNode[]) => void,
	parents: FigmaNode[] = [],
) {
	fn(node, parents);
	if (node.children) for (const c of node.children) traverseFigmaNodes(c, fn, parents.concat(node));
}

// Collect all icon components
function collectComponents(root: FigmaNode): ComponentRecord[] {
	const list: ComponentRecord[] = [];
	traverseFigmaNodes(root, (n) => {
		if (n.type === 'COMPONENT') list.push({ id: n.id, name: n.name });
	});
	return list;
}

// Normalize Figma component names to lowercase kebab for icon ids
function iconNameToId(componentName: string): string {
	return componentName
		.trim()
		.replace(/[\s_]+/g, '-')
		.replace(/([a-z0-9])([A-Z])/g, '$1-$2')
		.toLowerCase()
		.replace(/[^a-z0-9-]/g, '-')
		.replace(/--+/g, '-')
		.replace(/^-|-$/g, '');
}

// Get Figma SVG URLs to download
async function fetchSvgUrls(components: ComponentRecord[]): Promise<Record<string, string>> {
	const urls: Record<string, string> = {};
	for (let i = 0; i < components.length; i += IMAGES_BATCH_SIZE) {
		const batch = components.slice(i, i + IMAGES_BATCH_SIZE);
		const ids = batch.map((c) => c.id).join(',');
		const url = `https://api.figma.com/v1/images/${FIGMA_FILE_KEY}?ids=${encodeURIComponent(ids)}&format=svg`;
		log('figma', `Requesting image URLs for ${batch.length} component(s)`);
		const json = await figmaGet<{ images: Record<string, string> }>(url);
		for (const c of batch) if (json.images[c.id]) urls[c.id] = json.images[c.id];
	}
	return urls;
}

// Optimize SVG and strip all unnecessary data
function optimizeSvg(svg: string, debugName: string): string {
	const { data } = optimize(svg, {
		path: `${debugName}.svg`,
		multipass: true,
		plugins: [
			'removeDoctype',
			'removeXMLProcInst',
			'removeComments',
			'removeMetadata',
			'removeEditorsNSData',
			'cleanupAttrs',
			'minifyStyles',
			'convertStyleToAttrs',
			'cleanupIds',
			'removeUselessDefs',
			'cleanupNumericValues',
			'collapseGroups',
			'convertShapeToPath',
			'convertPathData',
			'removeEmptyAttrs',
			'removeEmptyText',
			'removeEmptyContainers',
			'removeUnusedNS',
			'sortAttrs',
			'removeUnknownsAndDefaults',
			// removes all fills
			{ name: 'removeAttrs', params: { attrs: 'fill' } },
			// security hardening
			{ name: 'removeScripts' },
			{ name: 'removeDimensions' },
			{ name: 'removeTitle' },
			{ name: 'removeDesc' },
		],
	});
	return data;
}

// Extract path from each icon's SVG file so we can create a symbol for the sprite
function extractSvgContentAndViewBox(svg: string): { viewBox: string; content: string } {
	const clean = svg.replace(/<\?xml[^>]*?>/g, '').trim();
	const m = clean.match(/<svg\b([^>]*)>([\s\S]*?)<\/svg>/i);
	if (!m) {
		// Fallback: wrap raw content if no outer <svg> found
		return { viewBox: '0 0 24 24', content: clean };
	}
	const attrs = m[1] ?? '';
	const inner = (m[2] ?? '').trim();
	const vb =
		/\bviewBox\s*=\s*"([^"]+)"/i.exec(attrs)?.[1] ??
		(() => {
			const w = /\bwidth\s*=\s*"([^"]+)"/i.exec(attrs)?.[1] ?? '24';
			const h = /\bheight\s*=\s*"([^"]+)"/i.exec(attrs)?.[1] ?? '24';
			return `0 0 ${w} ${h}`;
		})();
	return { viewBox: vb, content: inner };
}

// Create SVG sprite
function buildSprite(symbols: SvgSymbol[]): string {
	const blocks = symbols.map(({ name, svg }) => {
		const { viewBox, content } = extractSvgContentAndViewBox(svg);
		const inner = content
			.split('\n')
			.map((l) => (l.trim() ? `\t${l}` : l))
			.join('\n');
		return `\t<symbol id="lp-icon-${name}" viewBox="${viewBox}">\n\t${inner}\n\t</symbol>`;
	});

	return [
		`<!-- ${AUTO_GENERATED_BANNER}-->`,
		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`,
		...blocks,
		'</svg>',
		'', // trailing newline
	].join('\n');
}

// Write file contents. Used to write the svg symbols to the sprite and to write the ids to types.ts
async function writeFileAtomic(filePath: string, contents: string) {
	if (DRY_RUN) {
		log('fs', `(dry-run) would write ${path.relative(ROOT, filePath)} (${contents.length} bytes)`);
		return;
	}
	fs.mkdirSync(path.dirname(filePath), { recursive: true });
	const tmp = `${filePath}.tmp-${process.pid}`;
	fs.writeFileSync(tmp, contents, 'utf8');
	fs.renameSync(tmp, filePath);
}

function generateTypes(names: string): string {
	return `// ${AUTO_GENERATED_BANNER}
const icons = [
${names}
] as const;

type IconName = (typeof icons)[number];

export type { IconName };
export { icons };
`;
}

// Read existing icons from types.ts so we can diff with the icons read from the Figma File
function readExistingIcons(): string[] {
	try {
		if (!fs.existsSync(TYPES_PATH)) return [];
		const src = fs.readFileSync(TYPES_PATH, 'utf8');
		// Extract between const icons = [ ... ] as const
		const m = src.match(/const\s+icons\s*=\s*\[(.*?)\]\s+as\s+const/s);
		if (!m) return [];
		const body = m[1];
		const names: string[] = [];
		const rx = /['"]([^'"]+)['"]/g;
		let mm: RegExpExecArray | null;
		while (true) {
			mm = rx.exec(body);
			if (!mm) break;
			names.push(mm[1]);
		}
		return names;
	} catch {
		return [];
	}
}

// Download icons in small batches
async function mapPool<T, R>(
	items: T[],
	limit: number,
	worker: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
	const results: R[] = new Array(items.length);
	let i = 0;
	const run = async () => {
		while (true) {
			const idx = i++;
			if (idx >= items.length) return;
			results[idx] = await worker(items[idx], idx);
		}
	};
	const runners = Array.from({ length: Math.min(limit, items.length) }, run);
	await Promise.all(runners);
	return results;
}

// Main: bring it all together to generate icon sprite and type files
async function main(): Promise<void> {
	// 1) Get icon components
	const root = await fetchIconRoot();
	const components = collectComponents(root);
	if (components.length === 0) {
		log('warn', 'No components found at the specified node.');
		return;
	}
	log('discover', `Found ${components.length} component(s)`);

	// 2) Normalize names and dedupe by normalized name (first occurrence wins)
	const nameMap = new Map<string, ComponentRecord>();
	for (const c of components) {
		const name = iconNameToId(c.name);
		if (!name) continue;
		if (!nameMap.has(name)) nameMap.set(name, c);
	}
	const normalized = [...nameMap.entries()]
		.map(([name, comp]) => ({ ...comp, name }))
		.sort((a, b) => a.name.localeCompare(b.name));
	log('discover', `${normalized.length} unique normalized icon names`);

	// 3) Diff against existing types.ts before generating outputs
	const existingIcons = readExistingIcons();
	if (existingIcons.length) {
		const upcomingNames = normalized.map((n) => n.name);
		const existingSet = new Set(existingIcons);
		const upcomingSet = new Set(upcomingNames);
		const added = upcomingNames.filter((n) => !existingSet.has(n));
		const removed = existingIcons.filter((n) => !upcomingSet.has(n));
		if (added.length) console.info('[icons:diff] New icon(s) to add:', added.join(', '));
		if (removed.length)
			console.warn(
				'[icons:diff] Icon(s) no longer present and will be removed:',
				removed.join(', '),
			);
	} else {
		console.info('[icons:diff] No existing types.ts or no icons parsed; treating all as new.');
	}

	// 4) Resolve image URLs in batches
	const idToUrl = await fetchSvgUrls(normalized);

	// 4) Download + SVGO in parallel (bounded)
	const symbols = await mapPool(normalized, DOWNLOAD_CONCURRENCY, async (item) => {
		const url = idToUrl[item.id];
		if (!url) throw new Error(`Missing image URL for ${item.name} (${item.id})`);
		const raw = await downloadText(url);
		const optimized = optimizeSvg(raw, item.name);
		return { name: item.name, svg: optimized } as SvgSymbol;
	});

	// 5) Build deterministic, alphabetically-sorted sprite
	const sprite = buildSprite(symbols);
	await writeFileAtomic(SPRITE_PATH, sprite);
	log('sprite', `sprite.svg written with ${symbols.length} symbol(s)`);

	// 6) Write types.ts
	const namesBlock = symbols.map((s) => `\t'${s.name}',`).join('\n');
	const typesContent = generateTypes(namesBlock);
	await writeFileAtomic(TYPES_PATH, typesContent);
	log('types', `types.ts written (${symbols.length} icons)`);

	log('done', 'Icon refresh complete.');
}

main().catch((err) => {
	console.error('[icons:error]', err);
	process.exit(1);
});
